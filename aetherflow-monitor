#!/usr/bin/env python3
"""
üîç Aetherflow Monitor CLI - Interactive real-time monitoring
Usage:
    ./aetherflow-monitor                    # Monitor latest task
    ./aetherflow-monitor <task_id>          # Monitor specific task
    ./aetherflow-monitor --list             # List all tasks
    ./aetherflow-monitor --follow           # Follow latest task continuously
"""

import sys
import os
import time
import argparse
from pathlib import Path
from datetime import datetime
from collections import deque

# ANSI Colors
class Colors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
    DIM = '\033[2m'

# Search in all possible claude-code task directories (path depends on CWD at launch time)
_TMP_BASE = Path("/private/tmp/claude-501")
_KNOWN_DIRS = [
    _TMP_BASE / "-Users-francois-jeandazin-AETHERFLOW" / "tasks",
    _TMP_BASE / "-Users-francois-jeandazin-Antigravity-maiathon" / "tasks",
]
# Use first existing dir, fall back to AETHERFLOW default
OUTPUT_DIR = next((d for d in _KNOWN_DIRS if d.exists()), _KNOWN_DIRS[0])


def clear_screen():
    """Clear terminal screen."""
    os.system('clear' if os.name != 'nt' else 'cls')


def format_timestamp(ts_str):
    """Format timestamp from log."""
    try:
        # Extract time from "[32m21:01:02[0m"
        if '[0m' in ts_str:
            time_part = ts_str.split('[0m')[0].split('m')[-1]
            return f"{Colors.DIM}{time_part}{Colors.ENDC}"
        return ts_str
    except:
        return ts_str


def extract_api_info(line):
    """Extract API provider and action from line."""
    providers = {
        'groq': 'üöÄ Groq',
        'deepseek': 'üß† DeepSeek',
        'gemini': 'üíé Gemini',
        'codestral': '‚ö° Codestral',
        'kimi': 'üé® Kimi'
    }

    for key, display in providers.items():
        if key in line.lower():
            return display
    return None


def draw_progress_bar(progress, total, width=30):
    """Draw a simple progress bar."""
    if total == 0:
        return f"[{'‚îÄ' * width}] 0%"

    filled = int(width * progress / total)
    bar = '‚ñà' * filled + '‚ñë' * (width - filled)
    percentage = int(100 * progress / total)

    if percentage == 100:
        return f"{Colors.OKGREEN}[{bar}] {percentage}%{Colors.ENDC}"
    elif percentage >= 50:
        return f"{Colors.OKCYAN}[{bar}] {percentage}%{Colors.ENDC}"
    else:
        return f"{Colors.WARNING}[{bar}] {percentage}%{Colors.ENDC}"


def colorize_line(line):
    """Colorize log line based on content."""
    line = line.strip()

    # Remove ANSI codes for analysis
    clean_line = line
    for code in ['[32m', '[0m', '[1m', '[33m', '[31m', '[36m', '[35m', '[37m', '[2m', '[34m', '[36m']:
        clean_line = clean_line.replace(code, '')

    # Extract API info
    api_provider = extract_api_info(clean_line)
    if api_provider:
        line = f"{api_provider} {line}"

    # ERROR
    if 'ERROR' in clean_line or 'Failed' in clean_line or '‚ùå' in clean_line:
        return f"{Colors.FAIL}‚ùå {line}{Colors.ENDC}"

    # WARNING
    if 'WARNING' in clean_line or '‚ö†Ô∏è' in clean_line:
        return f"{Colors.WARNING}‚ö†Ô∏è  {line}{Colors.ENDC}"

    # SUCCESS / Completed
    if 'SUCCESS' in clean_line or '‚úÖ' in clean_line or 'Completed' in clean_line:
        return f"{Colors.OKGREEN}‚úÖ {line}{Colors.ENDC}"

    # Progress indicator
    if 'Progress:' in clean_line and '/' in clean_line:
        try:
            # Extract "X/Y steps"
            parts = clean_line.split('Progress:')[1].split('steps')[0].strip()
            current, total = map(int, parts.split('/'))
            bar = draw_progress_bar(current, total)
            return f"{Colors.BOLD}üìä Progress: {bar} ({current}/{total} steps){Colors.ENDC}"
        except:
            pass

    # Step execution
    if 'step_' in clean_line or 'Executing batch' in clean_line:
        return f"{Colors.OKCYAN}üîπ {line}{Colors.ENDC}"

    # Running status
    if 'Running' in clean_line or '‚ü≥' in clean_line:
        return f"{Colors.OKBLUE}‚ü≥ {line}{Colors.ENDC}"

    # Smart routing (API selection)
    if 'Smart routing' in clean_line or 'routing for' in clean_line:
        return f"{Colors.HEADER}üéØ {line}{Colors.ENDC}"

    # INFO
    if 'INFO' in clean_line:
        return f"{Colors.DIM}‚ÑπÔ∏è  {line}{Colors.ENDC}"

    # Monitor headers
    if '‚ï≠' in line or '‚ï∞' in line or '‚îÇ' in line or '‚îú' in line:
        return f"{Colors.OKCYAN}{line}{Colors.ENDC}"

    return line


def _all_task_files():
    """Return all task files from all known directories, sorted by mtime desc."""
    all_files = []
    for d in _KNOWN_DIRS:
        if d.exists():
            all_files.extend(d.glob("*.output"))
    return sorted(all_files, key=lambda f: f.stat().st_mtime, reverse=True)


def _find_task_file(task_id: str):
    """Find a task file by ID across all known directories."""
    for d in _KNOWN_DIRS:
        candidate = d / f"{task_id}.output"
        if candidate.exists():
            return candidate
    return None


def get_latest_task():
    """Get the latest task file across all known directories."""
    files = _all_task_files()
    return files[0] if files else None


def list_tasks():
    """List all available tasks."""
    task_files = _all_task_files()
    if not task_files:
        print(f"{Colors.FAIL}No tasks found in: {', '.join(str(d) for d in _KNOWN_DIRS)}{Colors.ENDC}")
        return

    task_files = task_files  # already sorted

    if not task_files:
        print(f"{Colors.WARNING}No tasks found.{Colors.ENDC}")
        return

    print(f"{Colors.HEADER}{Colors.BOLD}üìä Available Aetherflow Tasks{Colors.ENDC}")
    print(f"{Colors.DIM}{'='*60}{Colors.ENDC}\n")

    for i, task_file in enumerate(task_files[:10], 1):  # Show last 10
        task_id = task_file.stem
        size = task_file.stat().st_size
        mtime = datetime.fromtimestamp(task_file.stat().st_mtime)
        age = datetime.now() - mtime

        # Determine status from file content (check tail for final state)
        try:
            content = task_file.read_text(errors='ignore')
            tail = content[-3000:]  # only look at end of file for final status
            if 'workflow completed' in tail or 'plan execution completed' in tail or '‚úì Success' in tail:
                status = f"{Colors.OKGREEN}Done{Colors.ENDC}"
            elif '‚ü≥ Running' in tail or 'Running' in tail.split('\n')[-1]:
                status = f"{Colors.OKBLUE}Running{Colors.ENDC}"
            elif 'Interrupted' in tail or ('Failed' in tail and 'workflow' in tail.lower()):
                status = f"{Colors.FAIL}Failed{Colors.ENDC}"
            elif age.total_seconds() < 300:
                status = f"{Colors.OKBLUE}Running{Colors.ENDC}"
            else:
                status = f"{Colors.DIM}Done{Colors.ENDC}"
        except:
            status = f"{Colors.DIM}Unknown{Colors.ENDC}"

        print(f"{Colors.BOLD}{i}.{Colors.ENDC} {Colors.OKCYAN}{task_id}{Colors.ENDC}")
        print(f"   Status: {status}")
        print(f"   Time: {Colors.DIM}{mtime.strftime('%Y-%m-%d %H:%M:%S')} ({age.seconds}s ago){Colors.ENDC}")
        print(f"   Size: {Colors.DIM}{size:,} bytes{Colors.ENDC}")
        print()


def monitor_task(task_file, follow=False, tail_lines=50):
    """Monitor a specific task file."""
    if not task_file.exists():
        print(f"{Colors.FAIL}Task file not found: {task_file}{Colors.ENDC}")
        return

    task_id = task_file.stem

    # Header
    print(f"{Colors.HEADER}{Colors.BOLD}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó{Colors.ENDC}")
    print(f"{Colors.HEADER}{Colors.BOLD}‚ïë   Aetherflow Monitor v2.0            ‚ïë{Colors.ENDC}")
    print(f"{Colors.HEADER}{Colors.BOLD}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù{Colors.ENDC}")
    print()
    print(f"{Colors.OKGREEN}üìä Monitoring task: {Colors.BOLD}{task_id}{Colors.ENDC}")
    print(f"{Colors.DIM}üìÅ {task_file}{Colors.ENDC}")
    print()
    print(f"{Colors.WARNING}{'‚îÅ'*60}{Colors.ENDC}")
    print()

    if follow:
        # Follow mode - continuously update
        print(f"{Colors.OKCYAN}üì° Following in real-time... (Ctrl+C to stop){Colors.ENDC}\n")

        # Read existing content first
        with open(task_file, 'r', errors='ignore') as f:
            lines = deque(f.readlines(), maxlen=tail_lines)
            for line in lines:
                print(colorize_line(line.rstrip()))

        # Follow new lines
        with open(task_file, 'r', errors='ignore') as f:
            # Seek to end
            f.seek(0, 2)

            try:
                while True:
                    line = f.readline()
                    if line:
                        print(colorize_line(line.rstrip()))
                    else:
                        time.sleep(0.1)
            except KeyboardInterrupt:
                print(f"\n{Colors.OKCYAN}Monitor stopped.{Colors.ENDC}")
    else:
        # One-time display
        with open(task_file, 'r', errors='ignore') as f:
            lines = deque(f.readlines(), maxlen=tail_lines)
            for line in lines:
                print(colorize_line(line.rstrip()))

        print()
        print(f"{Colors.DIM}Showing last {tail_lines} lines. Use --follow to monitor in real-time.{Colors.ENDC}")


def main():
    parser = argparse.ArgumentParser(
        description='üîç Aetherflow Monitor - Interactive task monitoring',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  ./aetherflow-monitor                    # Monitor latest task
  ./aetherflow-monitor b6b1b0f            # Monitor specific task
  ./aetherflow-monitor --list             # List all tasks
  ./aetherflow-monitor --follow           # Follow latest task continuously
  ./aetherflow-monitor b6b1b0f --follow   # Follow specific task
        """
    )

    parser.add_argument('task_id', nargs='?', help='Task ID to monitor (default: latest)')
    parser.add_argument('--list', '-l', action='store_true', help='List all available tasks')
    parser.add_argument('--follow', '-f', action='store_true', help='Follow task output in real-time')
    parser.add_argument('--tail', '-n', type=int, default=50, help='Number of lines to show (default: 50)')

    args = parser.parse_args()

    # List mode
    if args.list:
        list_tasks()
        return

    # Determine which task to monitor
    if args.task_id:
        task_file = _find_task_file(args.task_id)
        if task_file is None:
            task_file = OUTPUT_DIR / f"{args.task_id}.output"  # fallback (will show not found)
    else:
        task_file = get_latest_task()
        if not task_file:
            print(f"{Colors.FAIL}No tasks found in {OUTPUT_DIR}{Colors.ENDC}")
            return

    # Monitor the task
    monitor_task(task_file, follow=args.follow, tail_lines=args.tail)


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n{Colors.OKCYAN}Exited.{Colors.ENDC}")
        sys.exit(0)
