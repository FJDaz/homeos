{
  "operations": [
    {
      "type": "modify_method",
      "target": "Orchestrator._execute_step",
      "position": "replace",
      "code": "    async def _execute_step(\n        self,\n        step: Step,\n        context: Optional[str],\n        previous_results: Dict[str, StepResult]\n    ) -> StepResult:\n        \"\"\"\n        Execute a single step.\n        \n        Args:\n            step: Step to execute\n            context: Additional context\n            previous_results: Results from previous steps\n            \n        Returns:\n            StepResult with execution results\n        \"\"\"\n        # Build context from previous results if needed\n        step_context = context or \"\"\n        \n        if step.dependencies:\n            # Add outputs from dependent steps to context\n            dep_outputs = []\n            for dep_id in step.dependencies:\n                if dep_id in previous_results:\n                    dep_result = previous_results[dep_id]\n                    if dep_result.success:\n                        dep_outputs.append(f\"Previous step {dep_id} output:\\n{dep_result.output}\")\n            \n            if dep_outputs:\n                step_context = \"\\n\\n\".join([step_context] + dep_outputs) if step_context else \"\\n\\n\".join(dep_outputs)\n        \n        # Load input_files (read-only) and inject as reference data\n        input_files = self._load_input_files(step)\n        if input_files:\n            ref_parts = [\"\\n\\nReference data (read-only, do not modify):\\n\"]\n            for path, content in input_files.items():\n                if content is not None:\n                    ref_parts.append(f\"=== File: {path} ===\\n{content}\\n\")\n            step_context = \"\\n\\n\".join([step_context] + ref_parts) if step_context else \"\".join(ref_parts)\n        \n        # Load existing files and inject into context\n        existing_files = self._load_existing_files(step)\n        surgical_mode = False\n        ast_contexts = {}\n\n        if existing_files:\n            # Check if surgical mode should be activated\n            # Surgical mode: enabled by default for refactoring/code_generation, or explicitly via step.context\n            project_root = Path(__file__).parent.parent.parent\n\n            # First, check if we have any Python files that exist AND have content\n            has_python_files = False\n            has_existing_code = False\n            for file_path_str, content in existing_files.items():\n                if content is not None and len(content.strip()) > 0:\n                    # File exists and has content\n                    has_existing_code = True\n                    file_path = Path(file_path_str)\n                    if not file_path.is_absolute():\n                        file_path = project_root / file_path\n                    if file_path.suffix == '.py' and file_path.exists():\n                        has_python_files = True\n                        break\n\n            # Surgical mode: ONLY if files exist with content\n            # Disabled for new files (content is None or empty)\n            surgical_mode = has_existing_code and (\n                self.execution_mode in [\"BUILD\", \"DOUBLE-CHECK\"] and\n                has_python_files and\n                step.type in ['refactoring', 'code_generation'] and\n                step.context.get('surgical_mode', True)\n            )\n\n            logger.info(f'Surgical mode: {surgical_mode} (execution_mode={self.execution_mode}, step_type={step.type}, has_python_files={has_python_files})')\n            \n            files_section_parts = [\"\\n\\nExisting code files:\\n\"]\n            \n            for file_path_str, content in existing_files.items():\n                if content is not None:\n                    files_section_parts.append(f\"=== File: {file_path_str} ===\\n{content}\\n\")\n                    \n                    # If surgical mode and Python file, parse AST\n                    if surgical_mode:\n                        file_path = Path(file_path_str)\n                        if not file_path.is_absolute():\n                            file_path = project_root / file_path\n                        \n                        if file_path.suffix == '.py' and file_path.exists():\n                            try:\n                                editor = SurgicalEditor(file_path)\n                                if editor.prepare():\n                                    ast_context = editor.get_ast_context()\n                                    ast_contexts[file_path_str] = ast_context\n                                    logger.info(f\"Parsed AST for {file_path_str} (surgical mode)\")\n                                else:\n                                    logger.warning(f\"Failed to prepare AST parser for {file_path_str}\")\n                            except Exception as e:\n                                logger.warning(f\"Failed to parse AST for {file_path_str}: {e}\")\n                                # Continue without AST for this file, but keep surgical mode enabled\n                                # if at least one file was successfully parsed\n            \n            if len(files_section_parts) > 1:  # More than just the header\n                files_section = \"\".join(files_section_parts)\n                \n                # Add AST context if surgical mode and we have parsed ASTs\n                if surgical_mode and ast_contexts:\n                    ast_section_parts = [\"\\n\\nAST Structure:\\n\"]\n                    for file_path_str, ast_context in ast_contexts.items():\n                        ast_section_parts.append(f\"=== File: {file_path_str} ===\\n{ast_context}\\n\")\n                    files_section += \"\\n\".join(ast_section_parts)\n                elif surgical_mode and not ast_contexts:\n                    # Surgical mode enabled but no AST parsed - warn but continue\n                    logger.warning(\"Surgical mode enabled but no AST contexts available. LLM will use file content only.\")\n                \n                # Add instructions based on step type and mode\n                if surgical_mode:\n                    files_section += \"\"\"\n\nSURGICAL MODE INSTRUCTIONS:\nGenerate ONLY these operation types (no others will work):\n- add_import: Add an import statement\n- add_function: Add a standalone function (NOT a route decorator, just the function)\n- add_class: Add a new class definition\n- add_method: Add a method to an existing class\n- modify_method: Modify an existing method\n- replace_import: Replace one import with another\n\nCRITICAL - FORBIDDEN OPERATIONS (will cause errors):\n❌ add_route (not supported)\n❌ add_to_router (not supported)\n❌ add_endpoint (not supported)\n❌ add_decorator (not supported)\n\nFor FastAPI routes, use add_function with the full decorated function:\n{\n  \"type\": \"add_function\",\n  \"code\": \"@router.get('/endpoint')\\\\nasync def my_endpoint():\\\\n    return {'status': 'ok'}\"\n}\n\nJSON structure:\n{\n  \"operations\": [\n    {\n      \"type\": \"add_method|modify_method|add_import|replace_import|add_class|add_function\",\n      \"target\": \"ClassName or ClassName.method_name\",\n      \"position\": \"after|before|end\",\n      \"after_method\": \"method_name\",\n      \"code\": \"def new_method(self): ...\"\n    }\n  ]\n}\n\nFocus on precise, minimal changes that integrate seamlessly with existing code.\n\"\"\"\n                else:\n                    if step.type == \"refactoring\":\n                        files_section += \"\\nModify the existing code above according to the requirements. Preserve existing structure, imports, and patterns.\\n\"\n                    elif step.type == \"code_generation\":\n                        files_section += \"\\nAdd new code to the existing files above. Ensure compatibility with existing imports and structure.\\n\"\n                    elif step.type == \"patch\":\n                        files_section += \"\\nGenerate ONLY the fragment to insert at the specified marker/line (patch mode). Do not output the complete file.\\n\"\n                \n                step_context = \"\\n\\n\".join([step_context, files_section]) if step_context else files_section\n        \n        # Execute step via AgentRouter (multi-provider)\n        # Pass surgical_mode flag to agent_router\n        # Pass loaded_files for smart context estimation\n        result = await self.agent_router.execute_step(\n            step, step_context, surgical_mode=surgical_mode, loaded_files=existing_files\n        )\n\n        # Apply surgical instructions if in surgical mode and execution succeeded\n        if surgical_mode and result.success and result.output:\n            from .core.surgical_editor import SurgicalInstructionParser\n\n            # Check if the output contains surgical instructions\n            if SurgicalInstructionParser.is_surgical_output(result.output):\n                logger.info(f\"Applying surgical instructions for step {step.id}\")\n\n                # Apply to each Python file that was parsed\n                applied_files = []\n                application_errors = []\n\n                for file_path_str in existing_files.keys():\n                    file_path = Path(file_path_str)\n                    if not file_path.is_absolute():\n                        file_path = project_root / file_path\n\n                    if file_path.suffix != '.py':\n                        continue\n\n                    if existing_files[file_path_str] is None:\n                        # NEW FILE: Create it directly using SurgicalEditor helper\n                        try:\n                            success, message = SurgicalEditor.create_new_file(file_path, result.output)\n                            if success:\n                                applied_files.append(f\"{file_path} (created)\")\n                                logger.info(message)\n                            else:\n                                # FALLBACK: Extract code from surgical JSON and write directly\n                                logger.warning(f\"Surgical creation failed for {file_path}: {message}\")\n                                logger.info(f\"Attempting fallback: extract code from operations\")\n\n                                from .core.surgical_editor import SurgicalInstructionParser\n                                operations, parse_error = SurgicalInstructionParser.parse_instructions(result.output)\n\n                                if operations:\n                                    # Extract all code from operations\n                                    code_parts = []\n                                    for op in operations:\n                                        if hasattr(op, 'code') and op.code:\n                                            code_parts.append(op.code)\n\n                                    if code_parts:\n                                        fallback_code = \"\\n\\n\".join(code_parts)\n                                        file_path.parent.mkdir(parents=True, exist_ok=True)\n                                        file_path.write_text(fallback_code, encoding='utf-8')\n                                        applied_files.append(f\"{file_path} (created via fallback)\")\n                                        logger.info(f\"✅ Fallback successful: wrote {len(fallback_code)} chars to {file_path}\")\n                                    else:\n                                        application_errors.append(f\"{file_path}: {message}\")\n                                        logger.warning(f\"Failed to create {file_path}: {message}\")\n                                else:\n                                    application_errors.append(f\"{file_path}: {message}\")\n                                    logger.warning(f\"Failed to create {file_path}: {message}\")\n                        except Exception as e:\n                            application_errors.append(f\"{file_path}: Failed to create new file: {e}\")\n                            logger.warning(f\"Error creating new file {file_path}: {e}\")\n                    else:\n                        # EXISTING FILE: Apply surgical edits\n                        if file_path.exists():\n                            try:\n                                editor = SurgicalEditor(file_path)\n                                if editor.prepare():\n                                    success, modified_code, original_code = editor.apply_instructions(result.output)\n\n                                    if success and modified_code:\n                                        # Write the modified code back to the file\n                                        file_path.write_text(modified_code, encoding='utf-8')\n                                        applied_files.append(f\"{file_path} (modified)\")\n                                        logger.info(f\"Applied surgical edits to {file_path}\")\n                                    elif not success:\n                                        # FALLBACK: Try to extract and append code\n                                        logger.warning(f"Surgical modification failed for {file_path}: {modified_code}")\n                                        logger.info(f"Attempting fallback: extract code from operations and append")\n\n                                        from .core.surgical_editor import SurgicalInstructionParser\n                                        operations, parse_error = SurgicalInstructionParser.parse_instructions(result.output)\n\n                                        if operations and original_code:\n                                            code_parts = []\n                                            for op in operations:\n                                                if hasattr(op, 'code') and op.code:\n                                                    code_parts.append(op.code)\n\n                                            if code_parts:\n                                                fallback_code = original_code + \"\\n\\n\" + \"\\n\\n\".join(code_parts)\n                                                file_path.write_text(fallback_code, encoding='utf-8')\n                                                applied_files.append(f\"{file_path} (modified via fallback - appended code)\")\n                                                logger.warning(f\"⚠️ Fallback used: appended {len(code_parts)} operations to {file_path}\")\n                                            else:\n                                                application_errors.append(f\"{file_path}: {modified_code}\")\n                                        else:\n                                            application_errors.append(f\"{file_path}: {modified_code}\")\n                            except Exception as e:\n                                application_errors.append(f\"{file_path}: {e}\")\n                                logger.warning(f"Error applying surgical edits to {file_path}: {e}\")\n\n                # Update result output with application summary\n                if applied_files:\n                    result.output = f"Surgical edits applied to: {', '.join(applied_files)}\\n\\nOriginal instructions:\\n{result.output}\"\n                if application_errors:\n                    result.output += f\"\\n\\nApplication errors:\\n\" + \"\\n\".join(application_errors)\n\n        return result"
    }
  ]
}