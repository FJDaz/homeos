{
  "task_id": "implement_quick_full_workflows",
  "description": "Implémenter les workflows quick (-q) et full (-f) dans le CLI avec rétrocompatibilité PROTO/PROD, et mettre à jour la règle Cursor pour application automatique des modifications",
  "steps": [
    {
      "id": "step_1",
      "description": "Ajouter les flags -q (quick) et -f (full) au CLI dans Backend/Prod/cli.py. Ajouter aussi --workflow quick|full avec rétrocompatibilité : quick → PROTO, full → PROD. Les flags -q et -f doivent être mutuellement exclusifs avec --fast et --build. Mettre à jour le groupe workflow_group pour inclure ces nouveaux flags.",
      "type": "code_generation",
      "complexity": 0.5,
      "estimated_tokens": 2000,
      "dependencies": [],
      "validation_criteria": [
        "Flags -q et -f ajoutés au parser",
        "--workflow quick|full ajouté avec rétrocompatibilité",
        "Groupe workflow_group mis à jour avec nouveaux flags",
        "Mutual exclusion respectée entre -q/-f et --fast/--build",
        "Rétrocompatibilité : quick → PROTO, full → PROD"
      ],
      "context": {
        "language": "python",
        "framework": "argparse",
        "files": [
          "Backend/Prod/cli.py"
        ]
      }
    },
    {
      "id": "step_2",
      "description": "Implémenter la logique d'exécution pour -q et -f dans Backend/Prod/cli.py. Si -q ou --workflow quick : utiliser ProtoWorkflow. Si -f ou --workflow full : utiliser ProdWorkflow. Ajouter la logique après la gestion de --fast et --build, avec rétrocompatibilité maintenue.",
      "type": "code_generation",
      "complexity": 0.6,
      "estimated_tokens": 2500,
      "dependencies": ["step_1"],
      "validation_criteria": [
        "Logique -q appelle ProtoWorkflow",
        "Logique -f appelle ProdWorkflow",
        "Logique --workflow quick appelle ProtoWorkflow",
        "Logique --workflow full appelle ProdWorkflow",
        "Rétrocompatibilité --fast et --build maintenue",
        "Messages d'erreur appropriés si plan manquant"
      ],
      "context": {
        "language": "python",
        "framework": "asyncio",
        "files": [
          "Backend/Prod/cli.py",
          "Backend/Prod/workflows/proto.py",
          "Backend/Prod/workflows/prod.py"
        ]
      }
    },
    {
      "id": "step_3",
      "description": "Mettre à jour les messages d'aide et la documentation dans Backend/Prod/cli.py pour inclure -q et -f. Ajouter exemples dans epilog : '%(prog)s -q --plan plan.json' et '%(prog)s -f --plan plan.json'. Mettre à jour les messages d'erreur pour mentionner -q/-f en plus de --fast/--build.",
      "type": "refactoring",
      "complexity": 0.3,
      "estimated_tokens": 1000,
      "dependencies": ["step_1", "step_2"],
      "validation_criteria": [
        "Epilog mis à jour avec exemples -q et -f",
        "Messages d'aide mentionnent quick/full",
        "Messages d'erreur mentionnent -q/-f",
        "Documentation cohérente"
      ],
      "context": {
        "language": "python",
        "framework": "argparse",
        "files": [
          "Backend/Prod/cli.py"
        ]
      }
    },
    {
      "id": "step_4",
      "description": "Mettre à jour la règle Cursor .cursor/rules/aetherflow-workflow.mdc pour préciser que Claude Code doit APPLIQUER automatiquement les modifications générées par BUILD. Ajouter section 'Application Automatique' expliquant que Claude Code doit : 1) Récupérer outputs via get_step_output(), 2) Parser le code généré, 3) Appliquer les modifications aux fichiers sources, 4) Présenter le résultat à l'utilisateur.",
      "type": "refactoring",
      "complexity": 0.4,
      "estimated_tokens": 1500,
      "dependencies": [],
      "validation_criteria": [
        "Section 'Application Automatique' ajoutée",
        "Workflow décrit : récupération → parsing → application → présentation",
        "Exemples de code pour application automatique",
        "Clarification que Claude Code applique, pas seulement présente"
      ],
      "context": {
        "language": "markdown",
        "framework": "cursor-rules",
        "files": [
          ".cursor/rules/aetherflow-workflow.mdc"
        ]
      }
    },
    {
      "id": "step_5",
      "description": "Créer fonction helper dans Backend/Prod/claude_helper.py pour appliquer automatiquement les modifications générées. Fonction apply_generated_code(step_output: str, target_file: Path) -> bool qui parse le code généré, identifie les modifications à faire, et applique les changements au fichier source. Utiliser regex ou AST pour identifier les blocs de code à modifier.",
      "type": "code_generation",
      "complexity": 0.7,
      "estimated_tokens": 3000,
      "dependencies": ["step_4"],
      "validation_criteria": [
        "Fonction apply_generated_code() créée",
        "Parse le code généré depuis step_output",
        "Identifie les fichiers cibles depuis context.files du plan",
        "Applique les modifications aux fichiers sources",
        "Gestion erreurs robuste",
        "Type hints complets"
      ],
      "context": {
        "language": "python",
        "framework": "pathlib",
        "files": [
          "Backend/Prod/claude_helper.py"
        ]
      }
    }
  ],
  "metadata": {
    "created_at": "2025-01-27T21:30:00Z",
    "claude_version": "claude-code",
    "project_context": "Implémenter workflows quick/full avec rétrocompatibilité et application automatique des modifications par Claude Code"
  }
}
