#Figma API EXPLOITATION
Utiliser **Figma comme un framework d'organisation hi√©rarchique** pour structurer le parcours HomeOS, avec des interfaces adapt√©es √† chaque niveau (Corps/Organes/Atomes). 
Voici la r√©interpr√©tation exacte de votre workflow :

L'exploitation de la typologie Figma doit commencer **d√®s l'Arbitrage**
# ABSTRACT : HOMEOS-FIGMA HI√âRARCHIQUE (VERSION CORRIG√âE)

## üéØ INTENTION FONDAMENTALE

Utiliser **la typologie Figma comme langage universel** d√®s la phase d'Arbitrage, permettant au Genome d'√™tre exprim√© en types Figma natifs pour une compatibilit√© 100% avec l'√©cosyst√®me Figma, transformant ainsi Figma en v√©rittable "runtime" de conception pour HomeOS.

## üìä ARCHITECTURE CONCEPTUELLE REVISIT√âE

### WORKFLOW COMPLET AVEC TYPOLOGIE FIGMA D√àS L'ARBITRAGE
```
IR (Intent Review)
    ‚Üì
ARBITRAGE SULLIVAN 
    ‚îî‚îÄ‚ñ∂ Exploitation de la TYPOLOGIE FIGMA
            ‚Üì
        Mapping Organic/Atomic ‚Üí Types Figma natifs
            ‚Üì
        GENOME (JSON 100% Figma-compatible)
            ‚îÇ   ‚Ä¢ Exprim√© en FRAMES, COMPONENT_SETS, INSTANCES
            ‚îÇ   ‚Ä¢ Structure hi√©rarchique pr√©serv√©e
            ‚îÇ   ‚Ä¢ Propri√©t√©s Figma natives
            ‚Üì
        [FOURCHE STRAT√âGIQUE]
            ‚îú‚îÄ‚ñ∂ 1. EXPORT DIRECT VERS FIGMA
            ‚îÇ       (le JSON est d√©j√† au bon format)
            ‚îÇ       ‚Üì
            ‚îÇ    Runtime Figma (√©dition visuelle)
            ‚îÇ       ‚Üì
            ‚îÇ    IMPORT FILTR√â + RECONNECTION
            ‚îÇ
            ‚îî‚îÄ‚ñ∂ 2. PARCOURS HOMEOS TOP-DOWN
                    ‚Üì
                INTERFACE CORPS = √âDITEUR DE FRAMES
                    (uniquement outils Frame Figma)
                    ‚Üì
                INTERFACE ORGANES = √âDITEUR DE COMPONENT_SETS
                    (uniquement outils Component Set)
                    ‚Üì
                INTERFACE ATOMES = √âDITEUR D'INSTANCES
                    (uniquement outils Instance/Override)
```

## üåü INNOVATION CL√â AJOUT√âE : **TYPOLOGIE FIGMA COMME LANGAGE D'ARBITRAGE**

### CE QUE √áA CHANGE TOUT :

**Avant (approche classique) :**
```
IR ‚Üí Sullivan ‚Üí Genome (format custom) ‚Üí Conversion ‚Üí Figma (perte s√©mantique)
```

**Maintenant (notre approche) :**
```
IR ‚Üí Sullivan Arbitrage ‚Üí Genome (format Figma natif) 
                         ‚îÇ
                         ‚îú‚îÄ‚ñ∂ Figma (direct, s√©mantique pr√©serv√©e)
                         ‚îî‚îÄ‚ñ∂ HomeOS (interpr√©tation native)
```

### EXPLOITATION DE LA TYPOLOGIE D√àS L'ARBITRAGE :

#### 1. **SULLIVAN DEVIENT "TRANSCRIPTEUR FIGMA"**
- Analyse l'IR et le traduit imm√©diatement en **concepts Figma**
- Ne pense plus en "composants g√©n√©riques" mais en :
  - `FRAME` (Corps)
  - `SECTION` (Groupes logiques)
  - `COMPONENT_SET` (Organes avec variants)
  - `COMPONENT` (Mol√©cules ma√Ætres)
  - `INSTANCE` (Atomes instanci√©s)

#### 2. **GENOME = MANIFESTE FIGMA**
```json
{
  "homeos_genome": {
    "version": "figma-2.0",
    "hierarchy": {
      "corps": [
        {
          "id": "dashboard",
          "figma_type": "FRAME",
          "figma_properties": {
            "layoutMode": "HORIZONTAL",
            "constraints": {"horizontal": "SCALE", "vertical": "SCALE"},
            "background": {"type": "SOLID", "color": "#FFFFFF"}
          },
          "children": ["header_set", "sidebar_set", "main_set"]
        }
      ],
      "organes": [
        {
          "id": "header_set",
          "figma_type": "COMPONENT_SET",
          "figma_properties": {
            "variantProperties": {
              "state": ["default", "logged_in", "logged_out"]
            }
          }
        }
      ]
    }
  }
}
```

#### 3. **B√âN√âFICE : PAS DE CONVERSION N√âCESSAIRE**
Le Genome est d√©j√† dans le **langage cible** :
- Export Figma : `POST /figma/files` avec le JSON tel quel
- Runtime HomeOS : Interpr√©tation directe des types Figma
- Modifications : Round-trip parfait entre les deux mondes

## üé® CONS√âQUENCES ARCHITECTURALES

### 1. **HOMEOS DEVIENT UN "FIGMA RUNTIME ALTERNATIF"**
- M√™mes concepts (Frames, Components, Instances)
- M√™mes propri√©t√©s (constraints, layoutMode, variantProperties)
- M√™mes op√©rations (create, update, override, detach)

### 2. **INTERFACES = VUES SP√âCIALIS√âES DE FIGMA**
- **Interface Corps** = Vue "Frames Only" de Figma
- **Interface Organes** = Vue "Component Sets Only" 
- **Interface Atomes** = Vue "Instances & Overrides Only"

### 3. **OUTILS = SOUS-ENSEMBLES D'OUTILS FIGMA**
Pour chaque niveau, seulement les outils pertinents :
- Niveau Corps : Outils Frame (dimensions, layout, export)
- Niveau Organes : Outils Component Set (variants, properties)
- Niveau Atomes : Outils Instance (overrides, detach, sync)

## üîÑ NOUVEAU WORKFLOW INTELLIGENT

### PHASE 1 : TRANSCRIPTION TYPOLOGIQUE
```
Intent Review ‚Üí 
  ‚Üì
Sullivan Arbitrage (avec connaissance Figma) ‚Üí 
  ‚Üì
"Cette IR correspond √† : 
  - 1 FRAME principal (Corps Dashboard)
  - 3 COMPONENT_SETS (Organes: Header, Sidebar, Main)  
  - 12 COMPONENTS (Mol√©cules)
  - 47 INSTANCES (Atomes)"
  ‚Üì
G√©n√©ration du Genome en JSON Figma-natif
```

### PHASE 2 : EX√âCUTION DUALISTE
```
Genome Figma-natif
    ‚îú‚îÄ‚ñ∂ BRANCHE A : FIGMA RUNTIME
    ‚îÇ       (√âdition visuelle, collaboration design)
    ‚îÇ       ‚Üì
    ‚îÇ    Modifications ‚Üí Diff detection ‚Üí HomeOS sync
    ‚îÇ
    ‚îî‚îÄ‚ñ∂ BRANCHE B : HOMEOS RUNTIME  
            (Construction programmatique, parcours guid√©)
            ‚Üì
        Interface Corps (Frame editor) ‚Üí 
          ‚Üì double-clic
        Interface Organes (Component Set editor) ‚Üí
          ‚Üì double-clic  
        Interface Atomes (Instance editor)
```

### PHASE 3 : SYNCHRONISATION BIDIRECTIONNELLE
- **Modif dans Figma** ‚Üí Detection de changements ‚Üí Update Genome
- **Modif dans HomeOS** ‚Üí Update properties ‚Üí Sync vers Figma
- **Conflict resolution** : Sullivan comme m√©diateur intelligent

## üß† IMPLICATIONS POUR SULLIVAN

### SULLIVAN DEVIENT "EXPERT FIGMA SEMANTICS"
- **Comprend** la grammaire Figma (Frames, Components, Instances)
- **Traduit** les intentions en structures Figma optimales
- **Optimise** selon les best practices Figma
- **Valide** la coh√©rence typologique

### ANALYSE PROSPECTIVE AVEC LANGAGE FIGMA
- Niveau Corps : "Ce FRAME devrait utiliser layoutMode: VERTICAL"
- Niveau Organes : "Ce COMPONENT_SET manque un variant 'loading'"
- Niveau Atomes : "Cette INSTANCE override trop de propri√©t√©s"

## üöÄ AVANTAGES RADICAUX DE CETTE APPROCHE

### 1. **ZERO CONVERSION OVERHEAD**
- Plus de transformateurs, adaptateurs, mappers
- Le Genome EST le format Figma
- Export/Import = copie directe

### 2. **COLLABORATION PARFAITE DESIGN/DEV**
- M√™me langage, m√™mes concepts
- M√™mes fichiers, m√™mes propri√©t√©s
- √âdition libre dans l'outil pr√©f√©r√©

### 3. **√âCOSYST√àME EXTENSIBLE**
- Plugins Figma compatibles directement
- API Figma utilisable telle quelle
- Communaut√© Figma comme ressource

### 4. **FUTURE-PROOF**
- Figma √©volue ‚Üí HomeOS √©volue automatiquement
- Nouvelles features Figma ‚Üí Nouvelles capacit√©s HomeOS
- Standards Figma = Standards HomeOS

## üîÆ VISION : HOMEOS COMME "FIGMA HEADLESS"

### FIGMA = FRONTEND VISUEL
- Interface graphique riche
- Outils de design complets
- Collaboration en temps r√©el

### HOMEOS = FRONTEND PROGRAMMATIQUE  
- Interface ax√©e construction
- Parcours guid√© top-down
- Intelligence int√©gr√©e (Sullivan)

### GENOME = SOURCE DE V√âRIT√â UNIQUE
- Format Figma-natif
- Interpr√©table par les deux runtimes
- Synchronisation bidirectionnelle

---

**EN ESSENCE** : Nous n'int√©grons pas Figma √† HomeOS. Nous faisons de **HomeOS une impl√©mentation sp√©cialis√©e de l'ontologie Figma**, avec un focus sur la construction guid√©e et l'intelligence int√©gr√©e, tandis que Figma reste l'outil de design visuel. Le Genome sert de lingua franca entre les deux mondes, exprim√© d√®s le d√©part dans le langage Figma pour √©liminer toute friction de conversion.

**LE CHANGEMENT PARADIGMATIQUE** : Au lieu de "comment exporter HomeOS vers Figma", nous pensons "comment exprimer HomeOS EN TERMES de Figma".

## üéØ VOTRE WORKFLOW REVISIT√â AVEC FIGMA COMME CADRE

```
IR ‚Üí Sullivan (Organic/Atomic mapping) ‚Üí Genome (JSON Figma-compatible)
        ‚Üì                                          ‚Üì
    [Arbiter]                              [FOURCHE D'EXPORT]
        ‚Üì                                          ‚îÇ
    Composants Figma                          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                              ‚ñº         ‚ñº
                                        1. Export ‚Üí 2. HomeOS Parcours
                                           Figma        √âcran 3
                                              ‚îÇ         ‚îÇ
                                              ‚îÇ         ‚ñº
                                              ‚îÇ     2.1 Corps = FRAME
                                              ‚îÇ        Interface d√©di√©e
                                              ‚îÇ         ‚îÇ
                                              ‚îÇ         ‚ñº
                                              ‚îÇ     2.2 Organes = ?
                                              ‚îÇ        Interface d√©di√©e  
                                              ‚îÇ         ‚îÇ
                                              ‚îÇ         ‚ñº
                                              ‚îÇ     2.3 Atomes = ?
                                              ‚îÇ        Interface d√©di√©e
                                              ‚îÇ
                                              ‚ñº
                                        Retour HomeOS
                                            [Arbiter Filtre]
```

## üóÇÔ∏è ARCHITECTURE HI√âRARCHIQUE FIGMA ‚Üí HOMEOs

### Niveau 1 : **Corps** = `FRAME` dans Figma
```json
{
  "type": "FRAME",
  "name": "Page_Dashboard",
  "corps_type": "dashboard",
  "children": ["Header", "Sidebar", "Main", "Footer"]
}
```

### Niveau 2 : **Organes** = `COMPONENT_SET` ou `GROUP` dans Figma
```json
{
  "type": "COMPONENT_SET",
  "name": "Organe_Header",
  "organe_type": "navigation",
  "variants": ["logged_in", "logged_out"],
  "children": ["Logo", "Menu", "UserMenu"]
}
```

### Niveau 3 : **Atomes** = `COMPONENT` ou `INSTANCE` dans Figma
```json
{
  "type": "COMPONENT",
  "name": "Atome_Button",
  "atome_type": "button",
  "props": {
    "variant": ["primary", "secondary"],
    "size": ["small", "medium", "large"]
  }
}
```

## üîß IMPL√âMENTATION CONCR√àTE

### 1. **Genome JSON Figma-compatible**

**Fichier :** `Backend/Prod/genome_figma_bridge.py`
```python
"""
Bridge entre Genome HomeOS et structure Figma
"""

from typing import Dict, List, Any
from dataclasses import dataclass, field
import json

@dataclass
class FigmaHierarchyNode:
    """Node hi√©rarchique pour Figma"""
    id: str
    name: str
    type: str  # "FRAME", "COMPONENT_SET", "COMPONENT", "INSTANCE"
    homeos_level: str  # "corps", "organe", "atome", "molecule"
    children: List[str] = field(default_factory=list)
    props: Dict[str, Any] = field(default_factory=dict)
    styles: Dict[str, Any] = field(default_factory=dict)
    metadata: Dict[str, Any] = field(default_factory=dict)

class GenomeToFigmaBridge:
    """
    Convertit le Genome HomeOS en structure hi√©rarchique Figma
    """
    
    # MAPPING HOMEOs ‚Üí FIGMA
    HOMEOs_TO_FIGMA = {
        "corps": {
            "figma_type": "FRAME",
            "default_size": {"width": 1440, "height": 1024},
            "exportable": True,
            "interface_level": 1
        },
        "organe": {
            "figma_type": "COMPONENT_SET",  # Ou SECTION selon complexit√©
            "default_size": {"width": "auto", "height": "auto"},
            "exportable": True,
            "interface_level": 2
        },
        "molecule": {
            "figma_type": "COMPONENT",
            "default_size": {"width": "auto", "height": "auto"},
            "exportable": True,
            "interface_level": 3
        },
        "atome": {
            "figma_type": "INSTANCE",  # Instance d'un COMPONENT
            "default_size": {"width": "auto", "height": "auto"},
            "exportable": True,
            "interface_level": 4
        }
    }
    
    def __init__(self, genome: Dict):
        self.genome = genome
        self.figma_structure = {}
        self.nodes = {}
        
    def convert_to_figma_hierarchy(self) -> Dict:
        """
        Convertit le Genome en hi√©rarchie Figma
        """
        
        # 1. Cr√©er les Corps (FRAMES)
        for corps in self.genome.get("corps", []):
            frame_node = self._create_frame_from_corps(corps)
            self.nodes[frame_node.id] = frame_node
            
            # 2. Cr√©er les Organes (COMPONENT_SETS)
            for organe in corps.get("organes", []):
                component_set_node = self._create_component_set_from_organe(organe)
                self.nodes[component_set_node.id] = component_set_node
                frame_node.children.append(component_set_node.id)
                
                # 3. Cr√©er les Mol√©cules/Atomes (COMPONENTS/INSTANCES)
                for molecule in organe.get("molecules", []):
                    component_node = self._create_component_from_molecule(molecule)
                    self.nodes[component_node.id] = component_node
                    component_set_node.children.append(component_node.id)
                    
                    # Atomes comme instances
                    for atome in molecule.get("atomes", []):
                        instance_node = self._create_instance_from_atome(atome, component_node.id)
                        self.nodes[instance_node.id] = instance_node
                        component_node.children.append(instance_node.id)
        
        # Structure finale compatible Figma
        self.figma_structure = {
            "document": {
                "id": "0:0",
                "name": self.genome.get("name", "HomeOS_Project"),
                "type": "DOCUMENT",
                "children": [node.id for node in self.nodes.values() 
                            if node.homeos_level == "corps"]
            },
            "components": self._extract_components_dict(),
            "nodes": {node.id: self._serialize_node(node) for node in self.nodes.values()}
        }
        
        return self.figma_structure
    
    def _create_frame_from_corps(self, corps: Dict) -> FigmaHierarchyNode:
        """Cr√©e un FRAME Figma √† partir d'un Corps"""
        
        return FigmaHierarchyNode(
            id=f"corps_{corps['id']}",
            name=corps["name"],
            type="FRAME",
            homeos_level="corps",
            props={
                "backgroundColor": corps.get("style", {}).get("backgroundColor", "#FFFFFF"),
                "layoutMode": corps.get("layout", {}).get("type", "NONE"),
                "constraints": {"horizontal": "SCALE", "vertical": "SCALE"}
            },
            styles=corps.get("style", {}),
            metadata={
                "homeos_id": corps["id"],
                "description": corps.get("description", ""),
                "intent": corps.get("intent", "")
            }
        )
    
    def _create_component_set_from_organe(self, organe: Dict) -> FigmaHierarchyNode:
        """Cr√©e un COMPONENT_SET Figma √† partir d'un Organe"""
        
        return FigmaHierarchyNode(
            id=f"organe_{organe['id']}",
            name=organe["name"],
            type="COMPONENT_SET",
            homeos_level="organe",
            props={
                "variantProperties": organe.get("variants", {}),
                "description": organe.get("description", "")
            },
            styles=organe.get("style", {}),
            metadata={
                "homeos_id": organe["id"],
                "parent_corps": organe.get("corps_id"),
                "function": organe.get("function", "")
            }
        )
    
    def _create_component_from_molecule(self, molecule: Dict) -> FigmaHierarchyNode:
        """Cr√©e un COMPONENT Figma √† partir d'une Mol√©cule"""
        
        return FigmaHierarchyNode(
            id=f"molecule_{molecule['id']}",
            name=molecule["name"],
            type="COMPONENT",
            homeos_level="molecule",
            props=molecule.get("props", {}),
            styles=molecule.get("style", {}),
            metadata={
                "homeos_id": molecule["id"],
                "parent_organe": molecule.get("organe_id"),
                "interactivity": molecule.get("interactivity", {})
            }
        )
    
    def _create_instance_from_atome(self, atome: Dict, parent_component_id: str) -> FigmaHierarchyNode:
        """Cr√©e une INSTANCE Figma √† partir d'un Atome"""
        
        return FigmaHierarchyNode(
            id=f"atome_{atome['id']}",
            name=atome["name"],
            type="INSTANCE",
            homeos_level="atome",
            props={
                "componentId": parent_component_id,
                "overrides": atome.get("overrides", {})
            },
            styles=atome.get("style", {}),
            metadata={
                "homeos_id": atome["id"],
                "parent_molecule": atome.get("molecule_id"),
                "element_type": atome.get("type", "element")
            }
        )
```

### 2. **INTERFACES D√âDI√âES PAR NIVEAU**

#### 2.1 **Interface Corps (FRAME)** - √âcran 3 du parcours

**Fichier :** `Frontend/interface_corps.html`
```html
<!-- Interface d√©di√©e aux Corps (Frames Figma) -->
<div id="corps-interface" class="homeos-interface" data-level="corps">
    
    <!-- HEADER sp√©cifique Corps -->
    <header class="interface-header">
        <h2>üèóÔ∏è Construction des Corps</h2>
        <div class="level-indicator">Niveau: Corps (Frames)</div>
        
        <!-- Outils sp√©cifiques aux Frames -->
        <div class="frame-tools">
            <button class="tool-btn" data-action="frame-add">
                <i>‚ûï</i> Nouveau Frame
            </button>
            <button class="tool-btn" data-action="frame-duplicate">
                <i>‚éò</i> Dupliquer
            </button>
            <button class="tool-btn" data-action="frame-arrange">
                <i>‚§¢</i> R√©organiser
            </button>
            <button class="tool-btn" data-action="frame-export-figma">
                <i>üì§</i> Exporter vers Figma
            </button>
        </div>
    </header>
    
    <!-- CANVAS principal pour les Corps -->
    <div class="corps-canvas">
        
        <!-- Liste des Corps (Frames) -->
        <div class="corps-list">
            <div class="corps-item" data-corps-id="dashboard" draggable="true">
                <div class="corps-preview" style="background: var(--color-primary-100);">
                    üìä Dashboard
                </div>
                <div class="corps-info">
                    <h4>Dashboard</h4>
                    <p>3 Organes ‚Ä¢ 12 Composants</p>
                    <button class="enter-corps" data-action="enter-corps">
                        ‚èé Entrer dans ce Corps
                    </button>
                </div>
            </div>
            
            <!-- Plus de Corps... -->
        </div>
        
        <!-- Analyse prospective Sullivan -->
        <div class="sullivan-analysis">
            <h3>üß† Analyse Sullivan (Niveau Corps)</h3>
            <div class="analysis-content">
                <p>¬´ Ce corps contient 3 organes principaux. Recommandation : 
                ajouter un organe de navigation lat√©rale pour am√©liorer l'UX. ¬ª</p>
                
                <div class="analysis-tools">
                    <button data-action="sullivan-suggest">üí° Suggestions</button>
                    <button data-action="sullivan-validate">‚úÖ Valider structure</button>
                    <button data-action="sullivan-optimize">‚ö° Optimiser</button>
                </div>
            </div>
        </div>
        
        <!-- Interface narrative (V n+1) -->
        <div class="narrative-interface">
            <h3>üìñ Histoire de construction</h3>
            <div class="construction-timeline">
                <div class="timeline-event">
                    <span class="time">10:30</span>
                    <span class="event">Cr√©ation du Corps "Dashboard"</span>
                </div>
                <div class="timeline-event">
                    <span class="time">10:45</span>
                    <span class="event">Ajout de l'organe "Header"</span>
                </div>
                <!-- Plus d'√©v√©nements... -->
            </div>
            
            <!-- RL sur histoires -->
            <div class="rl-suggestions">
                <h4>Suggestions bas√©es sur l'historique :</h4>
                <ul>
                    <li>Les projets similaires ajoutent un footer apr√®s le header</li>
                    <li>87% des dashboards ont une sidebar</li>
                </ul>
            </div>
        </div>
    </div>
    
    <!-- Sidebar d'outils r√©duite (uniquement pour Corps) -->
    <aside class="tools-sidebar">
        <h4>üõ†Ô∏è Outils Corps</h4>
        
        <!-- Uniquement les outils pertinents pour les Frames -->
        <div class="tool-section">
            <h5>Dimensions</h5>
            <input type="number" class="dimension-input" placeholder="Largeur" data-dimension="width">
            <input type="number" class="dimension-input" placeholder="Hauteur" data-dimension="height">
        </div>
        
        <div class="tool-section">
            <h5>Layout</h5>
            <select class="layout-select">
                <option value="NONE">Libre</option>
                <option value="HORIZONTAL">Horizontal</option>
                <option value="VERTICAL">Vertical</option>
            </select>
        </div>
        
        <div class="tool-section">
            <h5>Export</h5>
            <button class="export-btn" data-format="figma">üì§ Figma</button>
            <button class="export-btn" data-format="json">üìù JSON</button>
            <button class="export-btn" data-format="html">üåê HTML</button>
        </div>
    </aside>
</div>

<script>
// JavaScript sp√©cifique √† l'interface Corps
class CorpsInterface {
    constructor() {
        this.currentCorps = null;
        this.figmaBridge = new FigmaBridge();
        
        // √âv√©nements sp√©cifiques
        this.initCorpsEvents();
    }
    
    initCorpsEvents() {
        // Double-clic pour entrer dans un Corps
        document.querySelectorAll('.enter-corps').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const corpsId = e.target.closest('.corps-item').dataset.corpsId;
                this.enterCorps(corpsId);
            });
        });
        
        // Drag & drop pour r√©organiser les Corps
        this.initDragAndDrop();
        
        // Export vers Figma
        document.querySelector('[data-action="frame-export-figma"]').addEventListener('click', () => {
            this.exportToFigma();
        });
    }
    
    enterCorps(corpsId) {
        // Passer au niveau Organes √† l'int√©rieur de ce Corps
        window.location.href = `/homeos/organes?corps=${corpsId}`;
    }
    
    async exportToFigma() {
        // Exporter la structure Corps vers Figma
        const figmaStructure = await this.figmaBridge.exportCorpsToFigma(this.currentCorps);
        
        // Ouvrir dans Figma (ou sauvegarder pour import)
        const figmaUrl = `https://www.figma.com/file/new?nodes=${encodeURIComponent(JSON.stringify(figmaStructure))}`;
        window.open(figmaUrl, '_blank');
    }
}
</script>
```

#### 2.2 **Interface Organes** - Niveau 2

**Fichier :** `Frontend/interface_organes.html`
```html
<!-- Interface d√©di√©e aux Organes (Component Sets Figma) -->
<div id="organes-interface" class="homeos-interface" data-level="organes">
    
    <!-- HEADER sp√©cifique Organes -->
    <header class="interface-header">
        <h2>ü´Ä Construction des Organes</h2>
        <div class="level-indicator">
            Corps: <span id="current-corps">Dashboard</span> ‚Üí Niveau: Organes (Component Sets)
        </div>
        
        <!-- Outils sp√©cifiques aux Component Sets -->
        <div class="organe-tools">
            <button class="tool-btn" data-action="organe-add">
                <i>‚ûï</i> Nouvel Organe
            </button>
            <button class="tool-btn" data-action="organe-variant">
                <i>üîÑ</i> G√©rer Variants
            </button>
            <button class="tool-btn" data-action="organe-nest">
                <i>‚äÇ</i> Imbriquer
            </button>
            <button class="tool-btn" data-action="enter-atomes">
                <i>üî¨</i> Voir Atomes
            </button>
        </div>
    </header>
    
    <!-- Visualisation des Organes -->
    <div class="organes-visualization">
        
        <!-- Vue en arbre hi√©rarchique -->
        <div class="organes-tree">
            <div class="tree-node" data-type="corps">
                <div class="node-header">üìä Dashboard</div>
                <div class="node-children">
                    <div class="tree-node" data-type="organe">
                        <div class="node-header">üî§ Header (COMPONENT_SET)</div>
                        <div class="node-props">
                            <span class="prop">Variants: 2</span>
                            <span class="prop">Composants: 3</span>
                        </div>
                        <button class="enter-organe" data-action="enter-organe">
                            ‚èé Ouvrir cet Organe
                        </button>
                    </div>
                    
                    <div class="tree-node" data-type="organe">
                        <div class="node-header">üì¶ Sidebar (COMPONENT_SET)</div>
                        <!-- ... -->
                    </div>
                </div>
            </div>
        </div>
        
        <!-- √âditeur de variants (sp√©cifique Component Sets) -->
        <div class="variants-editor">
            <h3>üîÑ Variants d'Organe</h3>
            <div class="variants-list">
                <div class="variant-item" data-variant="default">
                    <div class="variant-preview"></div>
                    <div class="variant-name">Default</div>
                </div>
                <div class="variant-item" data-variant="compact">
                    <div class="variant-preview"></div>
                    <div class="variant-name">Compact</div>
                </div>
            </div>
            
            <button class="add-variant">‚ûï Ajouter Variant</button>
        </div>
        
        <!-- Interface Sullivan r√©duite (uniquement analyse Organes) -->
        <div class="sullivan-organe-analysis">
            <h3>üß† Analyse Sullivan (Niveau Organes)</h3>
            <p>¬´ Cet organe pourrait √™tre d√©compos√© en 2 mol√©cules distinctes
            pour une meilleure r√©utilisabilit√©. ¬ª</p>
        </div>
    </div>
</div>
```

#### 2.3 **Interface Atomes** - Niveau 3

**Fichier :** `Frontend/interface_atomes.html`
```html
<!-- Interface d√©di√©e aux Atomes (Instances/Components) -->
<div id="atomes-interface" class="homeos-interface" data-level="atomes">
    
    <!-- HEADER sp√©cifique Atomes -->
    <header class="interface-header">
        <h2>‚öõÔ∏è Construction des Atomes</h2>
        <div class="level-indicator">
            Corps: Dashboard ‚Üí Organe: Header ‚Üí Niveau: Atomes (Instances)
        </div>
        
        <!-- Outils sp√©cifiques aux Instances -->
        <div class="atome-tools">
            <button class="tool-btn" data-action="atome-instance">
                <i>‚éò</i> Nouvelle Instance
            </button>
            <button class="tool-btn" data-action="atome-override">
                <i>üé®</i> Override Style
            </button>
            <button class="tool-btn" data-action="atome-detach">
                <i>üîì</i> D√©tacher
            </button>
            <button class="tool-btn" data-action="atome-sync">
                <i>üîÑ</i> Sync avec Master
            </button>
        </div>
    </header>
    
    <!-- √âditeur visuel d'Atomes -->
    <div class="atomes-editor">
        
        <!-- Liste des Atomes disponibles -->
        <div class="atomes-library">
            <h3>üìö Biblioth√®que d'Atomes</h3>
            
            <div class="atome-component" data-component="button">
                <div class="component-preview">
                    <button class="btn-preview">Bouton</button>
                </div>
                <div class="component-info">
                    <h4>Button (COMPONENT)</h4>
                    <div class="component-props">
                        <span class="prop">variant: primary/secondary</span>
                        <span class="prop">size: sm/md/lg</span>
                    </div>
                    <button class="create-instance" data-component="button">
                        ‚éò Cr√©er Instance
                    </button>
                </div>
            </div>
            
            <!-- Plus de composants... -->
        </div>
        
        <!-- Zone d'instances -->
        <div class="instances-zone">
            <h3>üé≠ Instances d'Atomes</h3>
            <div class="instance" data-instance-id="btn1" data-component="button">
                <div class="instance-header">
                    <span class="instance-name">btn_primary</span>
                    <span class="instance-type">Instance de Button</span>
                </div>
                <div class="instance-overrides">
                    <div class="override">
                        <label>Variant:</label>
                        <select class="override-select" data-property="variant">
                            <option value="primary">Primary</option>
                            <option value="secondary">Secondary</option>
                        </select>
                    </div>
                    <div class="override">
                        <label>Taille:</label>
                        <select class="override-select" data-property="size">
                            <option value="sm">Petit</option>
                            <option value="md">Moyen</option>
                            <option value="lg">Grand</option>
                        </select>
                    </div>
                </div>
                <div class="instance-preview">
                    <!-- Pr√©visualisation dynamique -->
                </div>
            </div>
        </div>
        
        <!-- Inspecteur de propri√©t√©s (tr√®s d√©taill√© pour les Atomes) -->
        <div class="atome-inspector">
            <h3>üîç Inspecteur d'Atome</h3>
            
            <div class="inspector-section">
                <h4>Propri√©t√©s Figma</h4>
                <div class="prop-row">
                    <span class="prop-name">type:</span>
                    <span class="prop-value">INSTANCE</span>
                </div>
                <div class="prop-row">
                    <span class="prop-name">componentId:</span>
                    <span class="prop-value">molecule_button</span>
                </div>
            </div>
            
            <div class="inspector-section">
                <h4>Overrides</h4>
                <!-- √âditeur d'overrides dynamique -->
            </div>
            
            <div class="inspector-section">
                <h4>HomeOS Metadata</h4>
                <div class="prop-row">
                    <span class="prop-name">homeos_level:</span>
                    <span class="prop-value">atome</span>
                </div>
                <div class="prop-row">
                    <span class="prop-name">parent_molecule:</span>
                    <span class="prop-value">button_primary</span>
                </div>
            </div>
        </div>
    </div>
</div>
```

### 3. **ROUTAGE INTELLIGENT ENTRE NIVEAUX**

**Fichier :** `Backend/Prod/routes_hierarchy.py`
```python
"""
Routes pour la navigation hi√©rarchique HomeOS ‚Üî Figma
"""

from fastapi import APIRouter, Request, Query
from fastapi.responses import HTMLResponse, JSONResponse
from pathlib import Path

router = APIRouter()

@router.get("/homeos/corps")
async def corps_interface(request: Request):
    """
    Interface niveau Corps (Frames)
    """
    with open("Frontend/interface_corps.html", "r") as f:
        html = f.read()
    
    # Injecter le contexte
    html = html.replace("{{project_name}}", "Mon Projet")
    
    return HTMLResponse(html)

@router.get("/homeos/organes")
async def organes_interface(request: Request, corps_id: str = Query(...)):
    """
    Interface niveau Organes (Component Sets)
    Navigue √† l'int√©rieur d'un Corps sp√©cifique
    """
    with open("Frontend/interface_organes.html", "r") as f:
        html = f.read()
    
    # Charger les donn√©es du Corps
    corps_data = await load_corps_data(corps_id)
    
    # Injecter le contexte
    html = html.replace("{{corps_name}}", corps_data["name"])
    html = html.replace("{{corps_id}}", corps_id)
    
    return HTMLResponse(html)

@router.get("/homeos/atomes")
async def atomes_interface(request: Request, organe_id: str = Query(...)):
    """
    Interface niveau Atomes (Instances)
    Navigue √† l'int√©rieur d'un Organe sp√©cifique
    """
    with open("Frontend/interface_atomes.html", "r") as f:
        html = f.read()
    
    organe_data = await load_organe_data(organe_id)
    
    html = html.replace("{{organe_name}}", organe_data["name"])
    html = html.replace("{{organe_id}}", organe_id)
    
    return HTMLResponse(html)

@router.post("/export-to-figma/{level}")
async def export_to_figma(level: str, data: dict):
    """
    Exporte un niveau sp√©cifique vers Figma
    """
    exporter = FigmaExporter()
    
    if level == "corps":
        result = await exporter.export_corps_to_figma(data)
    elif level == "organes":
        result = await exporter.export_organes_to_figma(data)
    elif level == "atomes":
        result = await exporter.export_atomes_to_figma(data)
    else:
        return JSONResponse({"error": "Niveau invalide"}, status_code=400)
    
    return JSONResponse({
        "exported": True,
        "figma_url": result.get("url"),
        "file_key": result.get("file_key"),
        "level": level
    })

@router.post("/import-from-figma")
async def import_from_figma(file_key: str, level: str = "all"):
    """
    Importe depuis Figma et filtre/r√©attache les composants
    """
    importer = FigmaImporter()
    
    # Import depuis Figma
    figma_data = await importer.import_from_figma(file_key)
    
    # Arbiter Filtre : analyse ce qui a chang√©
    changes = await importer.analyze_changes(figma_data)
    
    # R√©attache les composants modifi√©s
    reattached = await importer.reattach_components(changes)
    
    return JSONResponse({
        "imported": True,
        "changes_detected": len(changes),
        "components_reattached": reattached,
        "new_components": changes.get("added", [])
    })
```

### 4. **SYST√àME D'HISTORIQUE ET RL**

**Fichier :** `Backend/Prod/construction_history.py`
```python
"""
Syst√®me d'historique de construction et RL
"""

from typing import List, Dict
from datetime import datetime
import json

class ConstructionHistory:
    """
    Track les actions de construction pour l'interface narrative
    et le Reinforcement Learning
    """
    
    def __init__(self):
        self.history = []
        self.patterns = {}
        
    def log_action(self, level: str, action: str, data: Dict):
        """Log une action de construction"""
        entry = {
            "timestamp": datetime.now().isoformat(),
            "level": level,  # "corps", "organe", "atome"
            "action": action,  # "create", "modify", "delete", "export", etc.
            "data": data,
            "user_context": self._get_user_context()
        }
        
        self.history.append(entry)
        
        # Sauvegarder pour RL
        self._extract_patterns(entry)
        
        return entry
    
    def get_construction_story(self, project_id: str) -> List[Dict]:
        """Retourne l'histoire narrative de construction"""
        project_history = [
            entry for entry in self.history 
            if entry.get("data", {}).get("project_id") == project_id
        ]
        
        # Formater pour l'interface narrative
        story = []
        for entry in project_history:
            story.append({
                "time": entry["timestamp"],
                "event": self._format_event(entry),
                "level": entry["level"],
                "significance": self._calculate_significance(entry)
            })
        
        return story
    
    def get_rl_suggestions(self, current_state: Dict) -> List[Dict]:
        """Retourne des suggestions bas√©es sur l'historique"""
        similar_patterns = self._find_similar_patterns(current_state)
        
        suggestions = []
        for pattern in similar_patterns:
            # Analyser ce qui a bien fonctionn√© dans le pass√©
            success_rate = pattern.get("success_rate", 0)
            if success_rate > 0.7:  # Seuil de confiance
                suggestions.append({
                    "action": pattern["common_next_action"],
                    "confidence": success_rate,
                    "reason": f"Cette action a r√©ussi dans {int(success_rate*100)}% des cas similaires",
                    "examples": pattern.get("examples", [])[:3]
                })
        
        return suggestions
    
    def _extract_patterns(self, entry: Dict):
        """Extrait des patterns pour le RL"""
        key = f"{entry['level']}:{entry['action']}"
        
        if key not in self.patterns:
            self.patterns[key] = {
                "count": 0,
                "successes": 0,
                "common_contexts": [],
                "common_next_actions": []
            }
        
        self.patterns[key]["count"] += 1
        
        # Suivre le contexte
        context = entry.get("user_context", {})
        self.patterns[key]["common_contexts"].append(context)
        
        # Suivre les actions suivantes (pour pr√©diction)
        if len(self.history) > 1:
            prev_entry = self.history[-2]
            next_action = f"{prev_entry['level']}:{prev_entry['action']} ‚Üí {key}"
            
            if next_action not in self.patterns[key]["common_next_actions"]:
                self.patterns[key]["common_next_actions"].append({
                    "action": next_action,
                    "count": 1
                })
            else:
                for action in self.patterns[key]["common_next_actions"]:
                    if action["action"] == next_action:
                        action["count"] += 1
```

## üöÄ WORKFLOW COMPLET REVISIT√â

```
IR (Intent Review)
    ‚Üì
Sullivan Arbiter
    ‚îú‚îÄ‚ñ∂ Organic Mapping ‚Üí Composants Figma structur√©s
    ‚îî‚îÄ‚ñ∂ Atomic Mapping
            ‚Üì
        Genome (JSON Figma-compatible)
            ‚Üì
        [FOURCHE]
            ‚îú‚îÄ‚ñ∂ 1. Export vers Figma
            ‚îÇ       ‚Üì
            ‚îÇ    Design dans Figma
            ‚îÇ       ‚Üì
            ‚îÇ    Retour HomeOS
            ‚îÇ       ‚Üì
            ‚îÇ    Arbiter Filtre (d√©tecte/rebranche)
            ‚îÇ
            ‚îî‚îÄ‚ñ∂ 2. HomeOS Parcours √âcran 3
                    ‚Üì
                2.1 Corps = FRAME
                    Interface d√©di√©e (outils r√©duits)
                    ‚Üì (double-clic)
                    
                2.2 Organes = COMPONENT_SET
                    Interface d√©di√©e
                    ‚Üì (double-clic)
                    
                2.3 Atomes = INSTANCE/COMPONENT
                    Interface d√©di√©e
                    
                    Avec √† chaque niveau:
                    ‚Ä¢ Analyse Sullivan prospective
                    ‚Ä¢ Interface narrative (construction story)
                    ‚Ä¢ RL sur histoires
```

## üéØ AVANTAGES DE CETTE APPROCHE

1. **Hi√©rarchie claire** : Figma comme m√©taphore structurante
2. **Interfaces adapt√©es** : Chaque niveau a ses outils sp√©cifiques
3. **R√©duction du bruit** : On ne voit que ce qui est pertinent
4. **Export/Import intelligent** : Bidirectionnel avec filtrage
5. **Apprentissage continu** : RL sur l'historique de construction
6. **Narratif int√©gr√©** : Histoire de la construction visible

**Voulez-vous que je d√©veloppe un niveau sp√©cifique en priorit√© ?** Corps, Organes ou Atomes ?
**Oui, c'est parfaitement possible et c'est m√™me une excellente strat√©gie.** C'est exactement ce que font des outils comme **Figma to Code** ou **Anima** - ils utilisent Figma comme "source de v√©rit√©" visuelle mais ajoutent leur propre logique par-dessus.

---

## **ARCHITECTURE : FIGMA COMME BACKEND VISUEL + HOMEOS SURCOUCHE**

### **Comment √ßa fonctionne :**

```
[User dans HomeOS]
        ‚Üì
[Actions HTMX/Tailwind]
        ‚Üì
[HomeOS Middleware] ‚Üê‚Üí [Cache Local]
        ‚Üì              (pour vitesse)
[API Figma] ‚Üí [File .fig]
        ‚Üì
[Sync Bidirectionnel]
        ‚Üì
[Canvas HomeOS] ‚Üê [Styles Tailwind mapp√©s]
```

### **1. LE CONCEPT TECHNIQUE**

Figma n'est pas **juste** un outil de design, c'est aussi une **API avec un format de fichier ouvert** (.fig = JSON compress√©).

```javascript
// Exemple de ce que Figma stocke
{
  "document": {
    "id": "0:0",
    "name": "Document",
    "type": "DOCUMENT",
    "children": [
      {
        "id": "1:2",
        "name": "Page 1",
        "type": "CANVAS",
        "children": [
          {
            "id": "2:3",
            "name": "Rectangle",
            "type": "RECTANGLE",
            "fills": [{...}],
            "absoluteBoundingBox": {...}
          }
        ]
      }
    ]
  }
}
```

### **2. LA SURCOUCHE HOMEOS**

HomeOS intercepte toutes les actions et ajoute sa logique :

```python
# Pseudo-code HomeOS Middleware
class HomeOSFigmaBridge:
    
    def handle_user_action(self, action, figma_node_id):
        # √âtape 1: Validation HomeOS
        if not self.validate_for_homeos(action):
            return {"error": "Violation des r√®gles HomeOS"}
        
        # √âtape 2: Transformation pour Figma
        figma_payload = self.transform_to_figma_format(action)
        
        # √âtape 3: Envoi √† Figma API
        response = self.figma_api.update_node(figma_node_id, figma_payload)
        
        # √âtape 4: Mise √† jour du cache local
        self.local_cache.update(response)
        
        # √âtape 5: Transformation pour Tailwind
        tailwind_classes = self.map_to_tailwind(response)
        
        # √âtape 6: G√©n√©ration du HTML/HTMX
        html_fragment = self.generate_htmx_fragment(tailwind_classes)
        
        return {
            "figma_updated": True,
            "local_cache": "updated",
            "html_preview": html_fragment,
            "tailwind_mapping": tailwind_classes
        }
```

---

## **EXEMPLE CONCRET : CR√âER UN BOUTON**

### **Sans HomeOS (pure Figma) :**
1. User dessine un rectangle
2. Ajoute du texte
3. Met une couleur
4. **Fin** - c'est juste un visuel

### **Avec HomeOS surcouche :**
1. User clique "Bouton HTMX" dans toolbar HomeOS
2. HomeOS cr√©e dans Figma :
   - Un rectangle avec `name: "btn_primary"`
   - Un texte enfant
   - Des m√©tadonn√©es custom : `{"homeos_type": "button", "hx_action": "/submit"}`
3. HomeOS mappe automatiquement :
   - `fills[0].color` ‚Üí `bg-indigo-600`
   - `cornerRadius` ‚Üí `rounded-lg`
   - `effects` ‚Üí `shadow-md`
4. HomeOS g√©n√®re le code :
```html
<button class="btn btn-primary bg-indigo-600 rounded-lg shadow-md"
        hx-post="/submit" hx-target="#result">
  {{ text_content }}
</button>
```

---

## **LES 3 COUCHES DE LA SURCOUCHE**

### **Couche 1 : Validation & R√®gles M√©tier**
```python
class HomeOSRules:
    RULES = {
        "button": {
            "min_width": 80,
            "min_height": 40,
            "required_children": ["text_layer"],
            "allowed_styles": ["primary", "secondary", "ghost"],
            "required_hx_attrs": True  # Doit avoir hx-get/post/etc
        },
        "input": {
            "must_have_label": True,
            "placeholder_required": True
        }
    }
```

### **Couche 2 : Mapping Figma ‚Üí Tailwind**
```python
class StyleMapper:
    def figma_to_tailwind(self, figma_style):
        mapping = {
            "fontSize": {
                12: "text-xs", 14: "text-sm", 16: "text-base",
                20: "text-xl", 24: "text-2xl"
            },
            "color": {
                "#3b82f6": "bg-blue-500",
                "#10b981": "bg-emerald-500"
            },
            "spacing": {
                "padding": self.px_to_spacing,
                "margin": self.px_to_spacing
            }
        }
```

### **Couche 3 : G√©n√©ration de Code**
```python
class CodeGenerator:
    def generate_component(self, figma_node, mapping):
        # √Ä partir d'un node Figma + mapping HomeOS
        # ‚Üí G√©n√®re du HTML/HTMX valide
        # ‚Üí G√©n√®re le CSS Tailwind correspondant
        # ‚Üí G√©n√®re le JSON pour le G√©nome
```

---

## **AVANTAGES DE CETTE APPROCHE**

### **1. Tu ne r√©inventes pas la roue**
- Canvas vectoriel : d√©j√† fait par Figma
- Outils de dessin : d√©j√† faits
- Syst√®me de calques : d√©j√† fait
- Collaboration : d√©j√† fait

### **2. Tu gardes le contr√¥le**
- HomeOS peut rejeter des actions
- HomeOS peut imposer des r√®gles
- HomeOS peut ajouter des m√©tadonn√©es
- HomeOS contr√¥le le code g√©n√©r√©

### **3. Interop√©rabilit√©**
- Les designers peuvent utiliser Figma normalement
- Puis importer dans HomeOS
- Ou travailler directement dans HomeOS
- Export possible vers d'autres outils

### **4. √âcosyst√®me existant**
- Plugins Figma d√©j√† disponibles
- Biblioth√®ques de design existantes
- Communaut√© √©norme

---

## **LIMITATIONS √Ä CONNA√éTRE**

### **API Figma a des limites :**
- Rate limiting : 2000 req/heure
- Pas d'√©criture en temps r√©el (polling ou webhooks)
- Certaines actions complexes n√©cessitent des workarounds

### **Solution : Cache local intelligent**
```python
class FigmaCache:
    def __init__(self):
        self.local_state = {}  # Version locale
        self.pending_changes = []  # File d'attente
        self.sync_interval = 5  # Sync toutes les 5 secondes
    
    def user_actions_fast(self):
        # Modifie d'abord le cache local
        self.local_state.update(changes)
        # Renvoie instantan√©ment √† l'UI
        return immediate_feedback
        
    def background_sync(self):
        # Plus tard, synchronise avec Figma
        for change in self.pending_changes:
            self.figma_api.apply(change)
```

---

## **MVP : COMMENCER SIMPLE**

### **Phase 1 - Lecture seule :**
1. User importe un fichier Figma existant
2. HomeOS analyse et propose des mappings
3. User valide/corrige
4. HomeOS g√©n√®re le code

### **Phase 2 - √âdition basique :**
1. User peut modifier du texte
2. User peut changer des couleurs (via palette pr√©d√©finie)
3. HomeOS map en Tailwind
4. Sync avec Figma en background

### **Phase 3 - Cr√©ation compl√®te :**
1. Toolbar compl√®te
2. Cr√©ation de composants
3. Mappings avanc√©s
4. Sync bidirectionnel

---

## **CONCR√àTEMENT POUR TOI**

**Commence avec :**
1. **`GET /v1/files/{file_key}`** - Lire un fichier Figma
2. **Parser le JSON** - Extraire la structure
3. **Mapper automatiquement** les styles ‚Üí Tailwind
4. **Afficher un preview** dans HomeOS
5. **Permettre d'√©diter le texte** et re-sync

```python
# Route initiale HomeOS
@app.post("/import-figma")
async def import_figma(file_key: str):
    # 1. Lire depuis Figma
    figma_data = await figma_api.get_file(file_key)
    
    # 2. Parser avec r√®gles HomeOS
    parsed = homeos_parser.parse(figma_data)
    
    # 3. G√©n√©rer preview
    html_preview = generator.generate_html(parsed)
    
    # 4. Stocker pour √©dition
    cache.store(file_key, {
        "figma_original": figma_data,
        "homeos_parsed": parsed,
        "html_preview": html_preview
    })
    
    return {"preview": html_preview, "editable": True}
```

---

**R√©sum√© : Oui, c'est 100% possible et m√™me recommand√©.** Tu utilises Figma comme moteur de rendu/stockage, mais HomeOS contr√¥le la logique m√©tier, les r√®gles, et la g√©n√©ration de code. C'est le meilleur des deux mondes.

**Prochaine √©tape :** Veux-tu que je te montre le code pour le mapper Figma‚ÜíTailwind ou l'architecture du cache local ?